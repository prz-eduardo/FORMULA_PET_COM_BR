<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>FORMULAPETCOMBR</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <script src="https://kit.fontawesome.com/530c5792d3.js" crossorigin="anonymous"></script>
  <script src="https://static.elfsight.com/platform/platform.js" defer></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Butterfly+Kids&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Barlow:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <script>
    (function(){
  // Create overlay container for paw prints (fixed) and an inner layer that we translate to mimic scroll
  var trail = document.createElement('div');
  trail.id = 'paw-trail';
  var layer = document.createElement('div');
  layer.id = 'paw-layer';
  trail.appendChild(layer);
  document.addEventListener('DOMContentLoaded', function(){ document.body.appendChild(trail); });

      // Random starting corner and direction (diagonal walk)
      function pickStart(){
        var corners = [
          { x: 0,   y: 100, dx: 1,  dy: -1 },  // bottom-left -> up-right
          { x: 100, y: 100, dx: -1, dy: -1 },  // bottom-right -> up-left
          { x: 0,   y: 0,   dx: 1,  dy: 1  },  // top-left -> down-right
          { x: 100, y: 0,   dx: -1, dy: 1  }   // top-right -> down-left
        ];
        return corners[Math.floor(Math.random()*corners.length)];
      }

      var state = pickStart();
  var stepPx = 72;        // distance between prints (px)
  var stepMs = 320;       // spawn interval (ms) - faster for more prints
  var sway = 60;          // more lateral randomness (px)
      var angleLeft = -22;    // alternating angle for left paw
      var angleRight = 22;    // alternating angle for right paw
      var left = true;
  var lifeMs = 3000;      // how long a print stays visible before fading (fade faster overall)

      var cachedPawSize = null;
      function getPawSize(){
        if (cachedPawSize != null) return cachedPawSize;
        try{
          var cs = getComputedStyle(document.documentElement);
          var val = cs.getPropertyValue('--paw-size');
          var n = parseFloat(val);
          cachedPawSize = isNaN(n) ? 56 : n;
        }catch(e){ cachedPawSize = 56; }
        return cachedPawSize;
      }
      function canPlaceAt(x, y){
        var minDist = getPawSize() * 0.9; // require at least ~1 footprint apart
        for (var i = 0; i < layer.children.length; i++){
          var c = layer.children[i];
          var px = parseFloat(c.getAttribute('data-x'));
          var py = parseFloat(c.getAttribute('data-y'));
          if (!isNaN(px) && !isNaN(py)){
            var dx = px - x;
            var dy = py - y;
            if (Math.hypot(dx, dy) < minDist) return false;
          }
        }
        return true;
      }

      var spawnPaused = false;
      function spawnPrint(){
        try{
          if (spawnPaused) { setTimeout(spawnPrint, stepMs); return; }
          var vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
          var vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
          var sy = (window.pageYOffset || document.documentElement.scrollTop || 0);
          // If off screen substantially, reset
          if (state.x < -20 || state.x > 120 || state.y < -20 || state.y > 120) {
            state = pickStart();
          }
          // Compute pixel position from percentage
          var baseX = (state.x/100)*vw;
          var baseY = sy + (state.y/100)*vh; // anchor Y to current scroll position
          var placed = false;
          var cx = baseX, cy = baseY;
          // Try a few random jitters to avoid overlapping existing prints
          for (var t = 0; t < 12; t++){
            cx = baseX + (Math.random()*2-1)*sway;
            cy = baseY + (Math.random()*2-1)*sway;
            if (canPlaceAt(cx, cy)) { placed = true; break; }
          }
          if (placed){
            var el = document.createElement('div');
            el.className = 'paw-print';
            el.style.left = cx + 'px';
            el.style.top = cy + 'px';
            el.setAttribute('data-x', String(cx));
            el.setAttribute('data-y', String(cy));
            // Compute direction-based rotation: vector from this step
            var dxPct = (stepPx / vw) * 100 * state.dx;
            var dyPct = (stepPx / vh) * 100 * state.dy;
            var dxPx = (dxPct/100) * vw;
            var dyPx = (dyPct/100) * vh;
            var baseAngle = Math.atan2(dyPx, dxPx) * 180 / Math.PI; // 0=east, 90=south
            var facing = baseAngle + 90; // rotate so 'top' of image points along vector
            var alt = left ? -12 : 12;   // subtle alternation for steps
            var angle = facing + alt;
            el.style.transform = 'translate(-50%, -50%) rotate(' + angle + 'deg)';
            layer.appendChild(el);
          }

          // Fade in
          if (placed){
            requestAnimationFrame(function(){ el.classList.add('show'); });
            // schedule fade-out and removal
            setTimeout(function(){
              try{
                el.classList.add('hide');
                setTimeout(function(){ if (el && el.parentNode) el.parentNode.removeChild(el); }, 800);
              }catch(e){}
            }, lifeMs);
          }

          // Advance along the path (convert step in px to % of viewport roughly)
          var dxPct = (stepPx / vw) * 100 * state.dx;
          var dyPct = (stepPx / vh) * 100 * state.dy;
          state.x += dxPct;
          state.y += dyPct;
          left = !left;

          // Limit total nodes to avoid memory leaks (higher cap for more prints)
          if (layer.childElementCount > 500){
            for (var i=0;i<80;i++) if (layer.firstChild) layer.removeChild(layer.firstChild);
          }
        }catch(e){}
        setTimeout(spawnPrint, stepMs);
      }

      // Prefill prints below the fold so you see paws even before scrolling
  function prefillBelowFold(screens, perScreen){
        try{
          var vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
          var vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
          var sy = (window.pageYOffset || document.documentElement.scrollTop || 0);
          screens = (typeof screens === 'number' && screens > 0) ? screens : 6;
          perScreen = (typeof perScreen === 'number' && perScreen > 0) ? perScreen : 16;
          // Direction and angle based on current state
          var dxPct = (stepPx / vw) * 100 * state.dx;
          var dyPct = (stepPx / vh) * 100 * state.dy;
          var dxPx = (dxPct/100) * vw;
          var dyPx = (dyPct/100) * vh;
          var baseAngle = Math.atan2(dyPx, dxPx) * 180 / Math.PI;
          // Only seed below the current viewport to avoid visible bursts
          for (var s=1; s<=screens; s++){
            for (var k=0; k<perScreen; k++){
              var cx = Math.random()*vw + (Math.random()*2-1)*(sway*0.5);
              var cy = sy + (s*vh) + (Math.random()*vh);
              if (!canPlaceAt(cx, cy)) continue;
              var alt = left ? -12 : 12;
              var angle = (baseAngle + 90) + alt;
              var el = document.createElement('div');
              el.className = 'paw-print';
              el.style.left = cx + 'px';
              el.style.top = cy + 'px';
              el.setAttribute('data-x', String(cx));
              el.setAttribute('data-y', String(cy));
              el.style.transform = 'translate(-50%, -50%) rotate(' + angle + 'deg)';
              layer.appendChild(el);
              // Fade in and schedule fade out
              requestAnimationFrame((function(node){ return function(){ node.classList.add('show'); }; })(el));
              (function(node){
                setTimeout(function(){
                  try{
                    node.classList.add('hide');
                    setTimeout(function(){ if (node && node.parentNode) node.parentNode.removeChild(node); }, 800);
                  }catch(e){}
                }, lifeMs + Math.random()*1500);
              })(el);
              left = !left;
            }
          }
        }catch(e){}
      }

      // Start when DOM ready
      document.addEventListener('DOMContentLoaded', function(){
        prefillBelowFold(6, 16);
        spawnPrint();
      });

      // As user scrolls, occasionally seed more prints just beyond view
      (function(){
        var scrollTimer = null;
        function onScroll(){
          spawnPaused = true; // pause spawning while scrolling
          // translate layer opposite to page scroll so prints appear to move with content
          try{
            var sy = (window.pageYOffset || document.documentElement.scrollTop || 0);
            layer.style.transform = 'translateY(' + (-sy) + 'px)';
          }catch(e){}
          if (scrollTimer) clearTimeout(scrollTimer);
          scrollTimer = setTimeout(function(){
            // scrolling stopped
            spawnPaused = false;
            try{ prefillBelowFold(2, 10); }catch(e){}
          }, 420);
        }
        window.addEventListener('scroll', onScroll, { passive: true });
      })();
    })();
  </script>
</head>
<body>
  <app-root></app-root>
</body>
</html>
